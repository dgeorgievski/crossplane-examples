{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to CrossPlane Examples All examples are based on a local CNOE IDP , which stands for a Cloud Native Operational Excelence Internal Developer Platform. Requirements idpbuilder CLI , 0.9.0+ CNOE IDP reference implementation stack Docker Host and CLI. Consider using the excellent and lightweight alternative to Docker Host, colima Kind K8s CLI kubectl 1.31+ Mkdocs 1.6.1+ to manage documentation. CNOE Implementations Used The following implementations will be deployed in the local Kind K8S cluster: Reference Implementation , that deploys the following components Argo Workflows to enable workflow orchestrations. Backstage as the UI for software catalog and templating. Source is available here. External Secrets to generate secrets and coordinate secrets between applications. Keycloak as the identity provider for applications. Spark Operator to demonstrate an example Spark workload through Backstage. CrossPlain integration for Backstage. Local Stack for testing cloud integrations. Spark Operator could be removed from the deployment. It fails to start due to a missing requirement, and more importantly it is not needed for the purpose of deploying the examples.","title":"Home"},{"location":"#welcome-to-crossplane-examples","text":"All examples are based on a local CNOE IDP , which stands for a Cloud Native Operational Excelence Internal Developer Platform.","title":"Welcome to CrossPlane Examples"},{"location":"#requirements","text":"idpbuilder CLI , 0.9.0+ CNOE IDP reference implementation stack Docker Host and CLI. Consider using the excellent and lightweight alternative to Docker Host, colima Kind K8s CLI kubectl 1.31+ Mkdocs 1.6.1+ to manage documentation.","title":"Requirements"},{"location":"#cnoe-implementations-used","text":"The following implementations will be deployed in the local Kind K8S cluster: Reference Implementation , that deploys the following components Argo Workflows to enable workflow orchestrations. Backstage as the UI for software catalog and templating. Source is available here. External Secrets to generate secrets and coordinate secrets between applications. Keycloak as the identity provider for applications. Spark Operator to demonstrate an example Spark workload through Backstage. CrossPlain integration for Backstage. Local Stack for testing cloud integrations. Spark Operator could be removed from the deployment. It fails to start due to a missing requirement, and more importantly it is not needed for the purpose of deploying the examples.","title":"CNOE Implementations Used"},{"location":"about/","text":"About Document various use cases with CrossPlane for managing cloud and non-cloud resources with the eye towards customizing CNOE IDP (Internal Developer Platform).","title":"About"},{"location":"about/#about","text":"Document various use cases with CrossPlane for managing cloud and non-cloud resources with the eye towards customizing CNOE IDP (Internal Developer Platform).","title":"About"},{"location":"cnoe-provisioning/","text":"Provisioning of CNOE IDP on a local Kind k8s cluster The CNOE IPD platform provides configurable stacks that could be used for various use cases. These example will use CNOE IPD with the following reference implementations: [Reference Implementation][defref], that deploys the following components Argo Workflows to enable workflow orchestrations. Backstage as the UI for software catalog and templating. Source is available here. External Secrets to generate secrets and coordinate secrets between applications. Keycloak as the identity provider for applications. Spark Operator to demonstrate an example Spark workload through Backstage. [CrossPlain][defcp] integration for Backstage. [Local Stack][deflocal] for testing cloud integrations. References: Reference Implementation It contains useful info on accessing and signing-in with individual services. Crossplane integration This integration targets Backstage. Provisioning steps Backstage deployment requires lots of CPU and Memory resources. Ensure the local Docker host is using configured to provide at least 6 CPU cores and 6 GB of RAM. The deployment of the stack was successfully test on a MacOS with colima using these settings colima start --cpu 6 --memory 6 Check colima's GitHub page for more information Provision CNOE IDP cluster. This might take several minutes depending on the available bandwidth and CPU/Memory resources availability. > idpbuilder create --use-path-routing \\ --name refstack \\ --package https://github.com/cnoe-io/stacks//ref-implementation \\ --package https://github.com/cnoe-io/stacks//crossplane-integrations \\ --package https://github.com/cnoe-io/stacks//localstack-integration # check the cluster availability > kind get clusters refstack Access CNOE services If successful you should be able to access the following services ArgoCD URL: https://cnoe.localtest.me:8443/argocd Run idpbuilder get secrets to get user name and password. Gitea The internal Git repo used primarily for demos. URL: https://cnoe.localtest.me:8443/gitea Run idpbuilder get secrets to get user name and password. KeyCloak Keycloak is an open-source Identity and Access Management (IAM) solution developed by Red Hat. URL: https://cnoe.localtest.me:8443/keycloak/admin/master/console/ user: cnoe-admin password: Run idpbuilder get secrets to get the value of KEYCLOAK_ADMIN_PASSWORD select the cnoe realm once successful log-in to manage identities. Backstage Backstage is an open source framework for building developer portals. Powered by a centralized software catalog, Backstage restores order to your microservices and infrastructure and enables your product teams to ship high-quality code quickly \u2014 without compromising autonomy. Backstage unifies all your infrastructure tooling, services, and documentation to create a streamlined development environment from end to end. URL: https://cnoe.localtest.me:8443/home There are two users set up in this configuration, and their password can be retrieved with the following command: idpbuilder get secrets Use the username user1 and the password value given by USER_PASSWORD field to login to the backstage instance. user1 is an admin user who has access to everything in the cluster, while user2 is a regular user with limited access. Both users use the same password retrieved above. Both users are managed by KeyCloak under the cnoe realm.","title":"CNOE IDP"},{"location":"cnoe-provisioning/#provisioning-of-cnoe-idp-on-a-local-kind-k8s-cluster","text":"The CNOE IPD platform provides configurable stacks that could be used for various use cases. These example will use CNOE IPD with the following reference implementations: [Reference Implementation][defref], that deploys the following components Argo Workflows to enable workflow orchestrations. Backstage as the UI for software catalog and templating. Source is available here. External Secrets to generate secrets and coordinate secrets between applications. Keycloak as the identity provider for applications. Spark Operator to demonstrate an example Spark workload through Backstage. [CrossPlain][defcp] integration for Backstage. [Local Stack][deflocal] for testing cloud integrations. References: Reference Implementation It contains useful info on accessing and signing-in with individual services. Crossplane integration This integration targets Backstage.","title":"Provisioning of CNOE IDP on a local Kind k8s cluster"},{"location":"cnoe-provisioning/#provisioning-steps","text":"Backstage deployment requires lots of CPU and Memory resources. Ensure the local Docker host is using configured to provide at least 6 CPU cores and 6 GB of RAM. The deployment of the stack was successfully test on a MacOS with colima using these settings colima start --cpu 6 --memory 6 Check colima's GitHub page for more information Provision CNOE IDP cluster. This might take several minutes depending on the available bandwidth and CPU/Memory resources availability. > idpbuilder create --use-path-routing \\ --name refstack \\ --package https://github.com/cnoe-io/stacks//ref-implementation \\ --package https://github.com/cnoe-io/stacks//crossplane-integrations \\ --package https://github.com/cnoe-io/stacks//localstack-integration # check the cluster availability > kind get clusters refstack","title":"Provisioning steps"},{"location":"cnoe-provisioning/#access-cnoe-services","text":"If successful you should be able to access the following services","title":"Access CNOE services"},{"location":"cnoe-provisioning/#argocd","text":"URL: https://cnoe.localtest.me:8443/argocd Run idpbuilder get secrets to get user name and password.","title":"ArgoCD"},{"location":"cnoe-provisioning/#gitea","text":"The internal Git repo used primarily for demos. URL: https://cnoe.localtest.me:8443/gitea Run idpbuilder get secrets to get user name and password.","title":"Gitea"},{"location":"cnoe-provisioning/#keycloak","text":"Keycloak is an open-source Identity and Access Management (IAM) solution developed by Red Hat. URL: https://cnoe.localtest.me:8443/keycloak/admin/master/console/ user: cnoe-admin password: Run idpbuilder get secrets to get the value of KEYCLOAK_ADMIN_PASSWORD select the cnoe realm once successful log-in to manage identities.","title":"KeyCloak"},{"location":"cnoe-provisioning/#backstage","text":"Backstage is an open source framework for building developer portals. Powered by a centralized software catalog, Backstage restores order to your microservices and infrastructure and enables your product teams to ship high-quality code quickly \u2014 without compromising autonomy. Backstage unifies all your infrastructure tooling, services, and documentation to create a streamlined development environment from end to end. URL: https://cnoe.localtest.me:8443/home There are two users set up in this configuration, and their password can be retrieved with the following command: idpbuilder get secrets Use the username user1 and the password value given by USER_PASSWORD field to login to the backstage instance. user1 is an admin user who has access to everything in the cluster, while user2 is a regular user with limited access. Both users use the same password retrieved above. Both users are managed by KeyCloak under the cnoe realm.","title":"Backstage"},{"location":"crossplane/","text":"CrossPlane concepts Important abstractions that are important to understand to fully grasp CrossPlane for automation and management of resources. Provider Providers enable Crossplane to provision infrastructure on an external service. Providers create new Kubernetes APIs and map them to external APIs. Providers are responsible for all aspects of connecting to non-Kubernetes resources. This includes authentication, making external API calls and providing Kubernetes Controller logic for any external resources. Examples of providers include: Provider AWS Provider Azure Provider GCP Provider Kubernetes Providers define every external resource they can create in Kubernetes as a Kubernetes API endpoint. These endpoints are Managed Resources. The following image depicts the relationship of Providers to CrossPlane controller, Resouces, Claims and Cloud platforms in which they provision and manage resources. References: Providers: https://docs.crossplane.io/latest/concepts/providers/ Compositions Compositions are a template for creating multiple managed resources as a single object. A Composition composes individual managed resources together into a larger, reusable, solution. An example Composition may combine a virtual machine, storage resources and networking policies. A Composition template links all these individual resources together. References: Compositions: https://docs.crossplane.io/latest/concepts/compositions/ Composite Resource Definitions Composite resource definitions (XRDs) define the schema for a custom API. Users create composite resources (XRs) and Claims (XCs) using the API schema defined by an XRD. References: Composite Resource Definitions: [https://docs.crossplane.io/latest/concepts/composite-resource-definitions/] Managed Resources A managed resource (MR) represents an external service in a Provider. When users create a new managed resource, the Provider reacts by creating an external resource inside the Provider\u2019s environment. Every external service managed by Crossplane maps to a managed resource. Crossplane calls the object inside Kubernetes a managed resource and the external object inside the Provider an external resource. References: Managed Resouces: https://docs.crossplane.io/latest/concepts/managed-resources/ Composite Resources A composite resource represents a set of managed resources as a single Kubernetes object. Crossplane creates composite resources when users access a custom API, defined in the CompositeResourceDefinition. Composite resources are a composite of managed resources. A Composition defines how to compose the managed resources together. References: Composite Resources: https://docs.crossplane.io/latest/concepts/composite-resources/ Claims Claims represents a set of managed resources as a single Kubernetes object, inside a namespace. Users create claims when they access the custom API, defined in the CompositeResourceDefinition. Claims are like composite resources. The difference between Claims and Composite Resources is Crossplane can create Claims in a namespace, while composite resources are cluster scoped. Kubernetes scope CrossPlane Resource K8S Scope Provider Namespace Compositions Cluster Compositions Cluster Composite Resource Definitions Cluster Managed Resources Cluster Composite Resources Cluster Claim Namespace","title":"CrossPlane Concepts"},{"location":"crossplane/#crossplane-concepts","text":"Important abstractions that are important to understand to fully grasp CrossPlane for automation and management of resources.","title":"CrossPlane concepts"},{"location":"crossplane/#provider","text":"Providers enable Crossplane to provision infrastructure on an external service. Providers create new Kubernetes APIs and map them to external APIs. Providers are responsible for all aspects of connecting to non-Kubernetes resources. This includes authentication, making external API calls and providing Kubernetes Controller logic for any external resources. Examples of providers include: Provider AWS Provider Azure Provider GCP Provider Kubernetes Providers define every external resource they can create in Kubernetes as a Kubernetes API endpoint. These endpoints are Managed Resources. The following image depicts the relationship of Providers to CrossPlane controller, Resouces, Claims and Cloud platforms in which they provision and manage resources. References: Providers: https://docs.crossplane.io/latest/concepts/providers/","title":"Provider"},{"location":"crossplane/#compositions","text":"Compositions are a template for creating multiple managed resources as a single object. A Composition composes individual managed resources together into a larger, reusable, solution. An example Composition may combine a virtual machine, storage resources and networking policies. A Composition template links all these individual resources together. References: Compositions: https://docs.crossplane.io/latest/concepts/compositions/","title":"Compositions"},{"location":"crossplane/#composite-resource-definitions","text":"Composite resource definitions (XRDs) define the schema for a custom API. Users create composite resources (XRs) and Claims (XCs) using the API schema defined by an XRD. References: Composite Resource Definitions: [https://docs.crossplane.io/latest/concepts/composite-resource-definitions/]","title":"Composite Resource Definitions"},{"location":"crossplane/#managed-resources","text":"A managed resource (MR) represents an external service in a Provider. When users create a new managed resource, the Provider reacts by creating an external resource inside the Provider\u2019s environment. Every external service managed by Crossplane maps to a managed resource. Crossplane calls the object inside Kubernetes a managed resource and the external object inside the Provider an external resource. References: Managed Resouces: https://docs.crossplane.io/latest/concepts/managed-resources/","title":"Managed Resources"},{"location":"crossplane/#composite-resources","text":"A composite resource represents a set of managed resources as a single Kubernetes object. Crossplane creates composite resources when users access a custom API, defined in the CompositeResourceDefinition. Composite resources are a composite of managed resources. A Composition defines how to compose the managed resources together. References: Composite Resources: https://docs.crossplane.io/latest/concepts/composite-resources/","title":"Composite Resources"},{"location":"crossplane/#claims","text":"Claims represents a set of managed resources as a single Kubernetes object, inside a namespace. Users create claims when they access the custom API, defined in the CompositeResourceDefinition. Claims are like composite resources. The difference between Claims and Composite Resources is Crossplane can create Claims in a namespace, while composite resources are cluster scoped.","title":"Claims"},{"location":"crossplane/#kubernetes-scope","text":"CrossPlane Resource K8S Scope Provider Namespace Compositions Cluster Compositions Cluster Composite Resource Definitions Cluster Managed Resources Cluster Composite Resources Cluster Claim Namespace","title":"Kubernetes scope"},{"location":"examples/","text":"CrossPlane Examples Kubernetes Provider Kubernetes provider is the simplest to use. It requires no integration with external Cloud platforms which makes the tests easy to implement. References: GitHub Repository: https://github.com/crossplane-contrib/provider-kubernetes Local Kind k8s cluster There are two options: Deploy kind and CrossPlane manually from the command line with kubectl. Deploy CNOE CrossPlane implementation. Create hello-world namespace manually Use kubectl to deploy the provider and the Object managed resource to provision a k8s namespace. > cd crossplane-examples/providers/k8s # deploy k8s provider, its configuration and RBAC cluster role to provide the required cluster-wide privlieges > kubectl create -f k8s-provider.yaml # Verify the deployment > kubectl get providers NAME INSTALLED HEALTHY PACKAGE AGE provider-aws True True xpkg.upbound.io/crossplane-contrib/provider-aws:v0.48.0 4d20h provider-kubernetes True True xpkg.upbound.io/upbound/provider-kubernetes:v0.16.0 3d21h # Deploy the Object managed resource that should create the hello-world namespace > kubectl create -f object.yaml # Verify the deployment > kubectl describe Object/hello-world Name: hello-world Namespace: Labels: <none> Annotations: crossplane.io/external-create-pending: 2025-05-15T18:56:57Z crossplane.io/external-create-succeeded: 2025-05-15T18:56:57Z crossplane.io/external-name: hello-world uptest.upbound.io/timeout: 60 API Version: kubernetes.crossplane.io/v1alpha2 Kind: Object Metadata: Creation Timestamp: 2025-05-15T18:56:57Z Finalizers: finalizer.managedresource.crossplane.io Generation: 2 Resource Version: 82477 UID: 0e1cb457-b367-46dd-902d-9cfbaf5e9231 Spec: Deletion Policy: Delete For Provider: Manifest: API Version: v1 Kind: Namespace Metadata: Labels: Example: true ... .... # Verify the creation of the k8s namespace > kubectl describe ns hello-world Name: hello-world Labels: example=true kubernetes.io/metadata.name=hello-world Annotations: <none> Status: Active No resource quota. No LimitRange resource. Create my-app-namespace namespace with Compositions and Claims In this example, the target namespace is managed through submission of a Claim. The Claim triggers a Composition to perform patching on the fields of the Claim, and the final results is used to create an Object, a managed resource of the Kubernetes provider. Create first the CompositeResourceDefinition (XRD) for custom xnamespaces.altimetrik.com XNamespaces Kind. > cd crossplane-examples/providers/k8s # check if the XRD exists > k api-resources | grep altimetrik.com (no result) # Create the XRD XNamespace > kubectl create -f ns/CompositeResourceDefinition.yaml compositeresourcedefinition.apiextensions.crossplane.io/xnamespaces.altimetrik.com created > kubectl api-resources | grep altimetrik.com namespaceclaims altimetrik.com/v1 true NamespaceClaim xnamespaces altimetrik.com/v1 false XNamespace # Create the Composition that will be used to transform the Claim into the # Provider's managed Resource > kubectl create -f ns/Composition.yaml # Create the NamespaceClaim in the default namespace. Keep in mind Claims are namespaced. > kubectl create -f ns/NamespaceClaim.yaml namespaceclaim.altimetrik.com/my-app-namespace created > kubectl get NamespaceClaims --all-namespaces NAMESPACE NAME SYNCED READY CONNECTION-SECRET AGE default my-app-namespace True True 27m # Verify the mu-app k8s namespace was created > kubectl describe ns/my-app Name: my-app Labels: app=my-application environment=production kubernetes.io/metadata.name=my-app Annotations: <none> Status: Active No resource quota. No LimitRange resource.","title":"Examples"},{"location":"examples/#crossplane-examples","text":"","title":"CrossPlane Examples"},{"location":"examples/#kubernetes-provider","text":"Kubernetes provider is the simplest to use. It requires no integration with external Cloud platforms which makes the tests easy to implement. References: GitHub Repository: https://github.com/crossplane-contrib/provider-kubernetes","title":"Kubernetes Provider"},{"location":"examples/#local-kind-k8s-cluster","text":"There are two options: Deploy kind and CrossPlane manually from the command line with kubectl. Deploy CNOE CrossPlane implementation.","title":"Local Kind k8s cluster"},{"location":"examples/#create-hello-world-namespace-manually","text":"Use kubectl to deploy the provider and the Object managed resource to provision a k8s namespace. > cd crossplane-examples/providers/k8s # deploy k8s provider, its configuration and RBAC cluster role to provide the required cluster-wide privlieges > kubectl create -f k8s-provider.yaml # Verify the deployment > kubectl get providers NAME INSTALLED HEALTHY PACKAGE AGE provider-aws True True xpkg.upbound.io/crossplane-contrib/provider-aws:v0.48.0 4d20h provider-kubernetes True True xpkg.upbound.io/upbound/provider-kubernetes:v0.16.0 3d21h # Deploy the Object managed resource that should create the hello-world namespace > kubectl create -f object.yaml # Verify the deployment > kubectl describe Object/hello-world Name: hello-world Namespace: Labels: <none> Annotations: crossplane.io/external-create-pending: 2025-05-15T18:56:57Z crossplane.io/external-create-succeeded: 2025-05-15T18:56:57Z crossplane.io/external-name: hello-world uptest.upbound.io/timeout: 60 API Version: kubernetes.crossplane.io/v1alpha2 Kind: Object Metadata: Creation Timestamp: 2025-05-15T18:56:57Z Finalizers: finalizer.managedresource.crossplane.io Generation: 2 Resource Version: 82477 UID: 0e1cb457-b367-46dd-902d-9cfbaf5e9231 Spec: Deletion Policy: Delete For Provider: Manifest: API Version: v1 Kind: Namespace Metadata: Labels: Example: true ... .... # Verify the creation of the k8s namespace > kubectl describe ns hello-world Name: hello-world Labels: example=true kubernetes.io/metadata.name=hello-world Annotations: <none> Status: Active No resource quota. No LimitRange resource.","title":"Create hello-world namespace manually"},{"location":"examples/#create-my-app-namespace-namespace-with-compositions-and-claims","text":"In this example, the target namespace is managed through submission of a Claim. The Claim triggers a Composition to perform patching on the fields of the Claim, and the final results is used to create an Object, a managed resource of the Kubernetes provider. Create first the CompositeResourceDefinition (XRD) for custom xnamespaces.altimetrik.com XNamespaces Kind. > cd crossplane-examples/providers/k8s # check if the XRD exists > k api-resources | grep altimetrik.com (no result) # Create the XRD XNamespace > kubectl create -f ns/CompositeResourceDefinition.yaml compositeresourcedefinition.apiextensions.crossplane.io/xnamespaces.altimetrik.com created > kubectl api-resources | grep altimetrik.com namespaceclaims altimetrik.com/v1 true NamespaceClaim xnamespaces altimetrik.com/v1 false XNamespace # Create the Composition that will be used to transform the Claim into the # Provider's managed Resource > kubectl create -f ns/Composition.yaml # Create the NamespaceClaim in the default namespace. Keep in mind Claims are namespaced. > kubectl create -f ns/NamespaceClaim.yaml namespaceclaim.altimetrik.com/my-app-namespace created > kubectl get NamespaceClaims --all-namespaces NAMESPACE NAME SYNCED READY CONNECTION-SECRET AGE default my-app-namespace True True 27m # Verify the mu-app k8s namespace was created > kubectl describe ns/my-app Name: my-app Labels: app=my-application environment=production kubernetes.io/metadata.name=my-app Annotations: <none> Status: Active No resource quota. No LimitRange resource.","title":"Create my-app-namespace namespace with Compositions and Claims"},{"location":"faq/","text":"FAQ What is CNOE? An open source initiative for building internal developer platforms (IDPs). Cloud Native Operational Excellence (aka, CNOE, pronounced Kuh.noo) is a joint effort to share developer tooling, thoughts, and patterns to help organizations make informed technology choices and resolve common pain points. CNOE will enable organizations to navigate tooling sprawl and technology churn by coordinating contributions, offering tools, and providing neutral and unbiased guidance on technology choices to deliver internal developer platforms. For more details, check https://cnoe.io/docs/intro/cnoe#what-is-cnoe CNOE Tenets Open source first: use of open source technology is prioritized over proprietary technology for each of the technology verticals discussed later in the doc. This helps ensure alignment across all the participating members by allowing them to coordinate on collaborations while having the freedom to update and modify a given technology to their needs Community driven: Decisions on the direction of the working group is driven by the community and its governing body. This involves the selection of technologies, level of commitment, and level of contribution. Tools and not Practices: CNOE offers suggestions on which tools to use and with what configurations. What practices a given company builds around and above those tools is out of scope for CNOE. Powered by Kubernetes, but not limited to orchestrate to Kubernetes: The CNOE working group relies heavily on the success of the CNCF community to choose technologies that are deemed useful to the type of operations required by the community. As such, Kubernetes is considered the de-facto environment to operate CNOE tooling. However, choosing of Kubernetes as the operating environment, does not require for it to be the environment to orchestrate against. Using the right infrastructure as code tooling, the CNOE community can choose to orchestrate against any compute platform of their choice. Standardized to the infrastructure, customizable by the developers: CNOE aims at addressing the usability requirements of its stakeholders. While the requirements of the platform could be enforced by the security engineers and infrastructure operators, the usability of it needs to be guaranteed by platform operators and application developers. Built to be shared: All CNOE deliverables including the reference architecture and the deployment packages will be developed out in the open and by collaboration of all its participating members and with the goal of making it sharable and usable by the larger open source community of interest. What is Internal Developer Platform An internal developer platform (IDP) is a self-service interface that provides developers with the tools and resources needed to build, deploy, and manage software applications efficiently. It simplifies the development process by abstracting complexity and enabling developers to focus on coding rather than infrastructure management. For more details, check https://internaldeveloperplatform.org/what-is-an-internal-developer-platform/","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#what-is-cnoe","text":"An open source initiative for building internal developer platforms (IDPs). Cloud Native Operational Excellence (aka, CNOE, pronounced Kuh.noo) is a joint effort to share developer tooling, thoughts, and patterns to help organizations make informed technology choices and resolve common pain points. CNOE will enable organizations to navigate tooling sprawl and technology churn by coordinating contributions, offering tools, and providing neutral and unbiased guidance on technology choices to deliver internal developer platforms. For more details, check https://cnoe.io/docs/intro/cnoe#what-is-cnoe","title":"What is CNOE?"},{"location":"faq/#cnoe-tenets","text":"Open source first: use of open source technology is prioritized over proprietary technology for each of the technology verticals discussed later in the doc. This helps ensure alignment across all the participating members by allowing them to coordinate on collaborations while having the freedom to update and modify a given technology to their needs Community driven: Decisions on the direction of the working group is driven by the community and its governing body. This involves the selection of technologies, level of commitment, and level of contribution. Tools and not Practices: CNOE offers suggestions on which tools to use and with what configurations. What practices a given company builds around and above those tools is out of scope for CNOE. Powered by Kubernetes, but not limited to orchestrate to Kubernetes: The CNOE working group relies heavily on the success of the CNCF community to choose technologies that are deemed useful to the type of operations required by the community. As such, Kubernetes is considered the de-facto environment to operate CNOE tooling. However, choosing of Kubernetes as the operating environment, does not require for it to be the environment to orchestrate against. Using the right infrastructure as code tooling, the CNOE community can choose to orchestrate against any compute platform of their choice. Standardized to the infrastructure, customizable by the developers: CNOE aims at addressing the usability requirements of its stakeholders. While the requirements of the platform could be enforced by the security engineers and infrastructure operators, the usability of it needs to be guaranteed by platform operators and application developers. Built to be shared: All CNOE deliverables including the reference architecture and the deployment packages will be developed out in the open and by collaboration of all its participating members and with the goal of making it sharable and usable by the larger open source community of interest.","title":"CNOE Tenets"},{"location":"faq/#what-is-internal-developer-platform","text":"An internal developer platform (IDP) is a self-service interface that provides developers with the tools and resources needed to build, deploy, and manage software applications efficiently. It simplifies the development process by abstracting complexity and enabling developers to focus on coding rather than infrastructure management. For more details, check https://internaldeveloperplatform.org/what-is-an-internal-developer-platform/","title":"What is Internal Developer Platform"}]}